{"name":"Cerebro","body":"Welcome to Cerebro!\r\n===================\r\n\r\nCerebro is a job deployment and monitoring system.    Cerebro fills the gap of having some code and deploying and managing it in a cloud environment.  The simplest usecase is taking a code package and deploying it on multiple machines in ec2 with monitoring and supervising on each process.\r\n\r\nCerebro is a process **supervisor**,   **deployment** and **management** solution.  \r\n\r\nBasic Feature List\r\n--------------------\r\n\r\n * Monitor an individual process on a cloud hosted VM\r\n * Reboot the process if necessary\r\n * Define constraints that the process cannot pass, or it'll be rebooted\r\n * Provide log access via an HTTP interface\r\n * Monitor and manage multiple of these processes per machine\r\n * Monitor many machines across a cluster\r\n * Deploy new machines, including process harness and job code\r\n * Accepts python classes to define how to deploy a process or job\r\n * Accept a job configuration via an HTTP API which defines how many of \r\n   each process to deploy in which datacenters on which cloud providers\r\n * The ability to autodetect if a machine goes bad / disappears, decomission it\r\n   and spin up an identcal replacement and redeploy to it, without any admin intervention.\r\n * Provides an HTML interface at the cluster level which gives you:\r\n   - The ability to update jobs in place\r\n   - An overview of what jobs are running on what machines, and where\r\n   - Links to the STDOUT/STDERR of every process in every job on every machine, \r\n     across the cluster.\r\n   - Basic machine vitals for all machines, including ram/cpu usage per process\r\n     and total machine utilization.\r\n\r\nWorkflow\r\n---------\r\n\r\nA basic workflow for using Cerebro, start to finish, is as follows in 10 easy steps:\r\n\r\n 0. Bundle your software into an easily deployable package (Using python buildout, for example)\r\n 1. Write a python \"deployment class\" (see docs below) for your package (short, maybe 30 lines of code)\r\n 2. Write a system-deployment configuration file which defines how many machines you want your code to run\r\n    on, what your credentials are for various cloud providers, dns provider etc.\r\n 3. Spinup a clustersitter on a cloud node (following simple deployment steps)\r\n 4. Run the \"job_update_cfg\" commnd and pass it your configuration and the location of your clustersitter\r\n 5. Look at the HTML UI, see things happen and find the provided DNS names for your machines\r\n 6. Get more customers, increase load, need more machines\r\n 7. Update the config file to require more machines\r\n 8. Again run job_update_cfg with your config file\r\n 9. Watch cerebro spin up more machines, and load to go back to acceptable levels\r\n\r\nUnder the Hood\r\n----------------\r\n\r\nCerebro is made up of three parts: Task Sitter a Machine Sitter and a Cluster Sitter\r\n\r\n### Task Sitter\r\nTask Sitter -- A harness to manage an arbitrary task or process.\r\n\r\nGoal: Instead of thinking about how many machines you need to run a process on\r\nthe task sitter's goal is to force the admin to think instead in terms of CPU\r\nand RAM, an to plan how much of each resource a process should use ahead of time.\r\n\r\nThe Task Sitter's job is to enforce the limits that the admin thinks a process\r\nshould obey.  It can handle the cases where a process disobeys these limits.\r\n\r\nTogether with a machine sitter a machine can be completely managed to run\r\nvarious tasks efficiently within the resource constraints of the machine.\r\n\r\nWith a cluster sitter an admin can define how many CPUs and how much RAM a particular\r\ntask can use and it can go to machines, look for available CPU and RAM where\r\nthe process fits and slot it in there.\r\n\r\nTask Sitter Details\r\n\r\n * Define constraints\r\n    * Should always be alive? (--ensure-alive)\r\n    * Fixed % of a CPU (--cpu)\r\n    * Fixed MB of RAM (--mem)\r\n    * Fixed lifetime (--time-limit)\r\n\r\n * Define runtime metadata\r\n    * User ID (--uid)\r\n    * Should the proc be restarted on violation? (--restart)\r\n    * Maximum # of reboots (--max-restarts)\r\n    * stdout / stderr directories (--std**-location)\r\n\r\n * Monitoring\r\n    * HTTP Based Monitor (--http-monitoring, --http-monitoring-port)\r\n\r\n### Machine Sitter\r\n\r\nMachine Sitter Details\r\n\r\n  * Monitor a set of TaskSitters\r\n  * Reboot TaskSitters if they fail (should never happen)\r\n  * Provide an API to add new tasks and start/stop tasks on a machine\r\n  * Provides central log access for all tasks\r\n\r\n### Cluster Sitter\r\n\r\nCluster Sitter Details\r\n\r\n  * Monitors a set of MachineSitters in a cluster\r\n  * Accepts 'Jobs' which define how many cpus/memory a particular task needs,\r\n finds or creates machines (and deploys machinesitters if necessary) and then\r\n activates the \"Jobs\" as tasks on each machine\r\n  * Provides a web UI to see where all your tasks are.\r\n  * Pulls in data and aggregates it from the cluster, to see task CPU\r\n usage, task rebooting behavior, machine performance data etc.\r\n  * Provides an abstract \"DeploymentRecipe\" class that you can fill out\r\n to have the clustersitter actually deploy your jobs automagically.\r\n  * Presently knows how to spinup/teardown AWS instances, though implementing\r\n other cloud providers should be pretty straightforward as there is a\r\n pretty minimal interface to the 'providers'.\r\n  * Assigns DNS names (presently only using the Dynect API) to machines\r\n    so they can automagically go live (see more in the 'How to do DNS' section)\r\n  * Decomissions machines if they fail, will spin up new ones as replacements.\r\n  * Supports the notion of linked jobs: When job A is linked to job B job A will be placed on\r\n    every and only the machines job A is placed on.  Job B will also be\r\n    rebooted whenever job A is updated.\r\n  * Keeps track of how many idle machiens you own, and can decomission them\r\n    to keep to a predefined limit.\r\n\r\n\r\n### Providers\r\n * Cerebro uses an interface for talking to both a cloud provider and a DNS provider\r\n * Presently only AWS/EC2 is implemented as a cloud-VM provider and Dynect is the only DNS providr\r\n * The interface is sufficiently minimal (aka create_instances() or dns_add_record()/dns_delete_record())\r\n    that it should be very simple to expand to other providers (linode, rackspace etc.)\r\n\r\nConfiguration\r\n--------------\r\n\r\nCerebro Configuration File:\r\n # See settings.py\r\n\r\nExample Job Configuration Format\r\n\r\n    {\r\n        \"dns_basename\": \"redis.startup.com\",\r\n        \"deployment_recipe\": \"mystartup.recipes.deploy\",\r\n        \"deployment_layout\": {\r\n            \"aws-us-west-2a\": {\r\n                \"mem\": 500,\r\n                \"cpu\": 1\r\n            },\r\n            \"aws-us-east-1b\": {\r\n                \"mem\": 50,\r\n                \"cpu\": 10\r\n            }\r\n        },\r\n        \"recipe_options\": {\r\n            # Passed as a dictionary to your jobs\r\n            \"release_dir\": \"/opt/startup/releases/\"\r\n        },\r\n        \"persistent\": true,\r\n        \"task_configuration\":\r\n            {\r\n                # Tasksitter configuration. \r\n                \"allow_exit\": false,\r\n                \"name\": \"Portal Server\",\r\n                \"command\": \"/opt/wifast/run_wsgi\",\r\n                \"auto_start\": false,\r\n                \"ensure_alive\": true,\r\n                \"max_restarts\": -1,\r\n                \"restart\": true,\r\n                \"uid\": 0,\r\n\t\t\"cpu\": .5, # allow this job to use 50% of CPU\r\n\t\t\"mem\": 1200, # Allow this job to use 1.2GB of RAM\r\n            }\r\n    },\r\n\r\n\r\nDeploymet Recipe Interface\r\n\r\n    def run_deploy(options):\r\n        # API?\r\n        logger.*()\r\n\r\nHow to do DNS \r\n\r\n  *  In the job configuration format there is a field called \"dns_basename\"\r\n  *  This should be set to something like \"myjobname.mydomain.com\" e.g. \"redis.startup.com\"\r\n  *  Cerebro will then add two new records underneath that name for each machine.  It will\r\n\r\n      1. Create #.PROVIDER_REGION.basename as a A record to the machine\r\n      2. Add another CNAME to PROVIDER_REGION.basename to #.PROVIDER_REGION etc.\r\n\r\n  * You should manually setup, e.g. \"redis.startup.com\" to be a cname to all of the PROVIDER_REGION.redis.startup.com.  A complete DNS layout looks as follows\r\n\r\n\r\n        startup.com\r\n        redis.startup.com (Admin Created)\r\n           -> CNAME aws-us-west-1.redis.startup.com (Admin Created)\r\n           -> CNAME aws-us-east-1.redis.startup.com (Admin Created)\r\n\r\n        aws-us-west-1.redis.startup.com (Admin Created)\r\n           -> A 45.67.20.106 (Cerebro Created)\r\n           -> A 45.67.20.105 (Cerebro Created)\r\n \r\n        0.aws-uswest-1.redis.startup.com (Cerebro Created)\r\n           -> A 45.67.20.106 (Cerebro Created)\r\n        1.aws-uswest-1.redis.startup.com (Cerebro Created)\r\n           -> A 45.67.20.105 (Cerebro Created)\r\n\r\n        aws-us-east-1.redis.startup.com (Admin Created)\r\n           -> A 12.67.20.106 (Cerebro Created)\r\n \r\n        0.aws-us-east-1.redis.startup.com (Cerebro Created)\r\n           -> A 12.67.20.106 (Cerebro Created)\r\n\r\n\r\nSo, if you point your servers to redis.startup.com they should get either \r\n\r\n  1. If your using global load balancing, a cname to one of aws-us-west-1.redis.startup.com or \r\n      aws-us-east-1.redis.startup.com based on the callers location\r\n  2. or both CNAMEs\r\n\r\nThe cname returns an A record for each machine of that type.  e.g. redis.startup.com -> aws-us-west-1.redis.startup.com -> 12.67.20.106\r\n","tagline":"Self hosted automated cloud deployment and management.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}